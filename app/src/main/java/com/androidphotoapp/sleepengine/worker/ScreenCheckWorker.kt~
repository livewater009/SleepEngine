package com.androidphotoapp.sleepengine.worker

import android.content.Context
import android.os.PowerManager
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.OutOfQuotaPolicy
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import com.androidphotoapp.sleepengine.ScreenStateHandler
import com.androidphotoapp.sleepengine.SleepConstants
import com.androidphotoapp.sleepengine.SleepUtils
import com.androidphotoapp.sleepengine.storage.LockTimeStore
import com.androidphotoapp.sleepengine.storage.ScreenStateStore
import java.util.concurrent.TimeUnit

class ScreenCheckWorker(
  context: Context,
  workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {

  override suspend fun doWork(): Result {
    Log.e("ScreenCheckWorker", "ðŸ”¥ Running ScreenCheckWorker")
    ScreenStateHandler.handleStateCheck(applicationContext, "ScreenCheckWorker")

    // Reschedule next worker
    Log.e("ScreenCheckWorker", "ðŸ”¥ Reschedule next work")
    scheduleNextWorker(SleepConstants.WORK_INTERVAL)
    
    return Result.success()
  }

  /** Private helper to schedule the next worker run */
  private fun scheduleNextWorker(intervalMinutes: Int) {
    val work = OneTimeWorkRequestBuilder<ScreenCheckWorker>()
      .setInitialDelay(intervalMinutes.toLong(), TimeUnit.MINUTES)
//      .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
      .build()

    WorkManager.getInstance(applicationContext).enqueueUniqueWork(
      "sleep_work_chain",
      ExistingWorkPolicy.REPLACE,
      listOf(work) // must wrap in list
    )

    Log.e("ScreenCheckWorker", "ðŸ”¥ Rescheduled correctly.")
  }
}
