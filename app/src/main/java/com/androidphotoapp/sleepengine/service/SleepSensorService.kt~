package com.androidphotoapp.sleepengine.service

import android.Manifest
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.media.MediaRecorder
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import com.androidphotoapp.sleepengine.R
import com.androidphotoapp.sleepengine.storage.SensorDataStore
import java.io.File
import java.io.IOException

class SleepSensorService : Service(), SensorEventListener {

  private lateinit var sensorManager: SensorManager
  private var accelerometer: Sensor? = null
  private var lightSensor: Sensor? = null

  private var mediaRecorder: MediaRecorder? = null
  private var audioThread: Thread? = null
  private var tempAudioFile: File? = null

  private val CHANNEL_ID = "sleep_sensor_channel"
  private val TAG = "SleepSensorService"

  override fun onCreate() {
    super.onCreate()
    Log.d(TAG, "Service onCreate")

    // Start foreground service with correct type
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
      startForeground(
        1,
        createNotification(),
        ServiceInfo.FOREGROUND_SERVICE_TYPE_MICROPHONE
      )
    } else {
      startForeground(1, createNotification())
    }

    // Initialize sensors
    sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
    accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
    lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)
  }

  override fun onDestroy() {
    super.onDestroy()
    stopTracking()
    stopAudioTracking()
    Log.d(TAG, "Service destroyed")
  }

  /** Start motion & light sensor tracking */
  private fun startTracking() {
    accelerometer?.let { sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI) }
    lightSensor?.let { sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI) }
    Log.d(TAG, "Sensors registered: Accelerometer=$accelerometer, Light=$lightSensor")

    startAudioTrackingSafely()
  }

  private fun stopTracking() {
    sensorManager.unregisterListener(this)
    Log.d(TAG, "Stopped tracking sensors")
  }

  /** Start audio recording safely */
  private fun startAudioTrackingSafely() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
      ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED
    ) {
      Log.e(TAG, "Audio permission not granted, skipping recording")
      return
    }

    try {
      tempAudioFile = File.createTempFile("sleep_audio", ".3gp", cacheDir)
      mediaRecorder = MediaRecorder().apply {
        setAudioSource(MediaRecorder.AudioSource.MIC)
        setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP)
        setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)
        setOutputFile(tempAudioFile!!.absolutePath)
        prepare()
        start()
      }

      Log.d(TAG, "Audio tracking started")

      audioThread = Thread {
        while (mediaRecorder != null) {
          try {
            val amplitude = mediaRecorder?.maxAmplitude ?: 0
            SensorDataStore.saveAudioAmplitude(applicationContext, amplitude.toFloat())
            Thread.sleep(1000)
          } catch (e: InterruptedException) {
            break
          } catch (e: Exception) {
            Log.e(TAG, "Error reading audio amplitude: ${e.message}")
            break
          }
        }
      }
      audioThread?.start()

    } catch (e: IOException) {
      Log.e(TAG, "MediaRecorder prepare/start failed: ${e.message}")
    } catch (e: RuntimeException) {
      Log.e(TAG, "MediaRecorder start failed: ${e.message}")
    }
  }

  private fun stopAudioTracking() {
    try {
      audioThread?.interrupt()
      audioThread = null

      mediaRecorder?.apply {
        stop()
        release()
      }
      mediaRecorder = null

      tempAudioFile?.delete()
      tempAudioFile = null

    } catch (e: Exception) {
      Log.e(TAG, "Error stopping audio: ${e.message}")
    }

    Log.d(TAG, "Stopped audio tracking")
  }

  override fun onSensorChanged(event: SensorEvent?) {
    event?.let {
      when (it.sensor.type) {
        Sensor.TYPE_ACCELEROMETER -> {
          SensorDataStore.saveMotionData(applicationContext, it.values[0], it.values[1], it.values[2])
        }
        Sensor.TYPE_LIGHT -> {
          SensorDataStore.saveLightData(applicationContext, it.values[0])
        }
      }
    }
  }

  override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}

  override fun onBind(intent: Intent?): IBinder? = null

  private fun createNotification(): Notification {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      val channel = NotificationChannel(
        CHANNEL_ID,
        "Sleep Sensor Service",
        NotificationManager.IMPORTANCE_LOW
      )
      val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
      manager.createNotificationChannel(channel)
    }

    return NotificationCompat.Builder(this, CHANNEL_ID)
      .setContentTitle("Sleep Tracking")
      .setContentText("Tracking motion, light, and audio")
      .setSmallIcon(R.drawable.ic_launcher_foreground)
      .setOngoing(true)
      .build()
  }

  override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    Log.d(TAG, "onStartCommand")
    startTracking()
    return START_STICKY
  }
}
